{"version":3,"file":"ng-diff-match-patch.umd.js.map","sources":["ng://ng-diff-match-patch/lib/diffMatchPatch.ts","ng://ng-diff-match-patch/lib/diffMatchPatch.service.ts",null,"ng://ng-diff-match-patch/lib/lineCompare.component.ts","ng://ng-diff-match-patch/lib/diff.directive.ts","ng://ng-diff-match-patch/lib/lineDiff.directive.ts","ng://ng-diff-match-patch/lib/processingDiff.directive.ts","ng://ng-diff-match-patch/lib/semanticDiff.directive.ts","ng://ng-diff-match-patch/lib/diffMatchPatch.module.ts"],"sourcesContent":["export const enum DiffOp {\n  Delete = -1,\n  Equal = 0,\n  Insert = 1\n}\n\nexport type Diff = [DiffOp, string];\n\n/**\n * Class containing the diff, match and patch methods.\n\n */\nclass DiffMatchPatch {\n\n  constructor() {  }\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  Patch_Margin = 4;\n\n  // The number of bits in an int.\n  Match_MaxBits = 32;\n  /**\n   * The data structure representing a diff is an array of tuples:\n   * [[DiffOp.Delete, 'Hello'], [DiffOp.Insert, 'Goodbye'], [DiffOp.Equal, ' world.']]\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n   */\n\n  // Define some regex patterns for matching boundaries.\n  whitespaceRegex_ = new RegExp('/\\s/');\n  linebreakRegex_ = new RegExp('/[\\r\\n]/');\n  blanklineEndRegex_ = new RegExp('/\\n\\r?\\n$/');\n  blanklineStartRegex_ = new RegExp('/^\\r?\\n\\r?\\n/');\n\n  /**\n   * Find the differences between two texts.  Simplifies the problem by stripping\n   * any common prefix or suffix off the texts before diffing.\n   * @param  text1 Old string to be diffed.\n   * @param  text2 New string to be diffed.\n   * @param  opt_checklines Optional speedup flag. If present and false,\n   *     then don't run a line-level diff first to identify the changed areas.\n   *     Defaults to true, which does a faster, slightly less optimal diff.\n   * @param  opt_deadline Optional time when the diff should be complete\n   *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n   *     instead.\n   * @return  Array of diff tuples.\n   */\n    diff_main (text1: string, text2: string, opt_checklines?: boolean, opt_deadline?: number): Array<Diff> {\n      // Set a deadline by which time the diff must be complete.\n      if (typeof opt_deadline == 'undefined') {\n        if (this.Diff_Timeout <= 0) {\n          opt_deadline = Number.MAX_VALUE;\n        } else {\n          opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n        }\n      }\n      const deadline = opt_deadline;\n\n      // Check for null inputs.\n      if (text1 == null || text2 == null) {\n        throw new Error('Null input. (diff_main)');\n      }\n\n      // Check for equality (speedup).\n      if (text1 == text2) {\n        if (text1) {\n          return [[DiffOp.Equal, text1]];\n        }\n        return [];\n      }\n\n      if (typeof opt_checklines == 'undefined') {\n        opt_checklines = true;\n      }\n      const checklines = opt_checklines;\n\n      // Trim off common prefix (speedup).\n      let commonlength = this.diff_commonPrefix(text1, text2);\n      const commonprefix = text1.substring(0, commonlength);\n      text1 = text1.substring(commonlength);\n      text2 = text2.substring(commonlength);\n\n      // Trim off common suffix (speedup).\n      commonlength = this.diff_commonSuffix(text1, text2);\n      const commonsuffix = text1.substring(text1.length - commonlength);\n      text1 = text1.substring(0, text1.length - commonlength);\n      text2 = text2.substring(0, text2.length - commonlength);\n\n      // Compute the diff on the middle block.\n      const diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n      // Restore the prefix and suffix.\n      if (commonprefix) {\n        diffs.unshift([DiffOp.Equal, commonprefix]);\n      }\n      if (commonsuffix) {\n        diffs.push([DiffOp.Equal, commonsuffix]);\n      }\n      this.diff_cleanupMerge(diffs);\n      return diffs;\n  };\n\n\n  /**\n   * Find the differences between two texts.  Assumes that the texts do not\n   * have any common prefix or suffix.\n   * @param  text1 Old string to be diffed.\n   * @param  text2 New string to be diffed.\n   * @param  checklines Speedup flag.  If false, then don't run a\n   *     line-level diff first to identify the changed areas.\n   *     If true, then run a faster, slightly less optimal diff.\n   * @param  deadline Time when the diff should be complete by.\n   * @return  Array of diff tuples.\n\n   */\n    diff_compute_ (text1: string, text2: string, checklines: boolean,\n      deadline: number): Array<Diff> {\n    let diffs: Array<Diff>;\n\n    if (!text1) {\n      // Just add some text (speedup).\n      return [[DiffOp.Insert, text2]];\n    }\n\n    if (!text2) {\n      // Just delete some text (speedup).\n      return [[DiffOp.Delete, text1]];\n    }\n\n    const longtext = text1.length > text2.length ? text1 : text2;\n    const shorttext = text1.length > text2.length ? text2 : text1;\n    const i = longtext.indexOf(shorttext);\n    if (i != -1) {\n      // Shorter text is inside the longer text (speedup).\n      diffs = [[DiffOp.Insert, longtext.substring(0, i)],\n              [DiffOp.Equal, shorttext],\n              [DiffOp.Insert, longtext.substring(i + shorttext.length)]];\n      // Swap insertions for deletions if diff is reversed.\n      if (text1.length > text2.length) {\n        diffs[0][0] = diffs[2][0] = DiffOp.Delete;\n      }\n      return diffs;\n    }\n\n    if (shorttext.length == 1) {\n      // Single character string.\n      // After the previous speedup, the character can't be an equality.\n      return [[DiffOp.Delete, text1], [DiffOp.Insert, text2]];\n    }\n\n    // Check to see if the problem can be split in two.\n    const hm = this.diff_halfMatch_(text1, text2);\n    if (hm) {\n      // A half-match was found, sort out the return data.\n      const text1_a = hm[0];\n      const text1_b = hm[1];\n      const text2_a = hm[2];\n      const text2_b = hm[3];\n      const mid_common = hm[4];\n      // Send both pairs off for separate processing.\n      const diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n      const diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n      // Merge the results.\n      return diffs_a.concat([[DiffOp.Equal, mid_common]], diffs_b);\n    }\n\n    if (checklines && text1.length > 100 && text2.length > 100) {\n      return this.diff_lineMode_(text1, text2, deadline);\n    }\n\n    return this.diff_bisect_(text1, text2, deadline);\n  };\n\n\n  /**\n   * Do a quick line-level diff on both strings, then rediff the parts for\n   * greater accuracy.\n   * This speedup can produce non-minimal diffs.\n   * @param  text1 Old string to be diffed.\n   * @param  text2 New string to be diffed.\n   * @param  deadline Time when the diff should be complete by.\n   * @return  Array of diff tuples.\n\n   */\n    diff_lineMode_ (text1: string, text2: string, deadline: number) {\n    // Scan the text on a line-by-line basis first.\n    const a = this.diff_linesToChars_(text1, text2);\n    text1 = a.chars1;\n    text2 = a.chars2;\n    const linearray = a.lineArray;\n\n    const diffs = this.diff_main(text1, text2, false, deadline);\n\n    // Convert the diff back to original text.\n    this.diff_charsToLines_(diffs, linearray);\n    // Eliminate freak matches (e.g. blank lines)\n    this.diff_cleanupSemantic(diffs);\n\n    // Rediff any replacement blocks, this time character-by-character.\n    // Add a dummy entry at the end.\n    diffs.push([DiffOp.Equal, '']);\n    let pointer = 0;\n    let count_delete = 0;\n    let count_insert = 0;\n    let text_delete = '';\n    let text_insert = '';\n    while (pointer < diffs.length) {\n      switch (diffs[pointer][0]) {\n        case DiffOp.Insert:\n          count_insert++;\n          text_insert += diffs[pointer][1];\n          break;\n        case DiffOp.Delete:\n          count_delete++;\n          text_delete += diffs[pointer][1];\n          break;\n        case DiffOp.Equal:\n          // Upon reaching an equality, check for prior redundancies.\n          if (count_delete >= 1 && count_insert >= 1) {\n            // Delete the offending records and add the merged ones.\n            diffs.splice(pointer - count_delete - count_insert,\n                        count_delete + count_insert);\n            pointer = pointer - count_delete - count_insert;\n            const b = this.diff_main(text_delete, text_insert, false, deadline);\n            for (let j = b.length - 1; j >= 0; j--) {\n              diffs.splice(pointer, 0, b[j]);\n            }\n            pointer = pointer + b.length;\n          }\n          count_insert = 0;\n          count_delete = 0;\n          text_delete = '';\n          text_insert = '';\n          break;\n      }\n      pointer++;\n    }\n    diffs.pop();  // Remove the dummy entry at the end.\n\n    return diffs;\n  };\n\n\n  /**\n   * Find the 'middle snake' of a diff, split the problem in two\n   * and return the recursively constructed diff.\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its constiations.\n   * @param  text1 Old string to be diffed.\n   * @param  text2 New string to be diffed.\n   * @param  deadline Time at which to bail if not yet complete.\n   * @return  Array of diff tuples.\n\n   */\n    diff_bisect_ (text1: string, text2: string, deadline: number): Array<Diff> {\n    // Cache the text lengths to prevent multiple calls.\n    const text1_length = text1.length;\n    const text2_length = text2.length;\n    const max_d = Math.ceil((text1_length + text2_length) / 2);\n    const v_offset = max_d;\n    const v_length = 2 * max_d;\n    const v1 = new Array(v_length);\n    const v2 = new Array(v_length);\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n    // integers and undefined.\n    for (let x = 0; x < v_length; x++) {\n      v1[x] = -1;\n      v2[x] = -1;\n    }\n    v1[v_offset + 1] = 0;\n    v2[v_offset + 1] = 0;\n    const delta = text1_length - text2_length;\n    // If the total number of characters is odd, then the front path will collide\n    // with the reverse path.\n    const front = (delta % 2 != 0);\n    // Offsets for start and end of k loop.\n    // Prevents mapping of space beyond the grid.\n    let k1start = 0;\n    let k1end = 0;\n    let k2start = 0;\n    let k2end = 0;\n    for (let d = 0; d < max_d; d++) {\n      // Bail out if deadline is reached.\n      if ((new Date()).getTime() > deadline) {\n        break;\n      }\n\n      // Walk the front path one step.\n      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n        const k1_offset = v_offset + k1;\n        let x1;\n        if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n          x1 = v1[k1_offset + 1];\n        } else {\n          x1 = v1[k1_offset - 1] + 1;\n        }\n        let y1 = x1 - k1;\n        while (x1 < text1_length && y1 < text2_length &&\n              text1.charAt(x1) == text2.charAt(y1)) {\n          x1++;\n          y1++;\n        }\n        v1[k1_offset] = x1;\n        if (x1 > text1_length) {\n          // Ran off the right of the graph.\n          k1end += 2;\n        } else if (y1 > text2_length) {\n          // Ran off the bottom of the graph.\n          k1start += 2;\n        } else if (front) {\n          const k2_offset = v_offset + delta - k1;\n          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n            // Mirror x2 onto top-left coordinate system.\n            const x2 = text1_length - v2[k2_offset];\n            if (x1 >= x2) {\n              // Overlap detected.\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n            }\n          }\n        }\n      }\n\n      // Walk the reverse path one step.\n      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n        const k2_offset = v_offset + k2;\n        let x2: number;\n        if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n          x2 = v2[k2_offset + 1];\n        } else {\n          x2 = v2[k2_offset - 1] + 1;\n        }\n        let y2 = x2 - k2;\n        while (x2 < text1_length && y2 < text2_length &&\n              text1.charAt(text1_length - x2 - 1) ==\n              text2.charAt(text2_length - y2 - 1)) {\n          x2++;\n          y2++;\n        }\n        v2[k2_offset] = x2;\n        if (x2 > text1_length) {\n          // Ran off the left of the graph.\n          k2end += 2;\n        } else if (y2 > text2_length) {\n          // Ran off the top of the graph.\n          k2start += 2;\n        } else if (!front) {\n          const k1_offset = v_offset + delta - k2;\n          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n            const x1 = v1[k1_offset];\n            const y1 = v_offset + x1 - k1_offset;\n            // Mirror x2 onto top-left coordinate system.\n            x2 = text1_length - x2;\n            if (x1 >= x2) {\n              // Overlap detected.\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n            }\n          }\n        }\n      }\n    }\n    // Diff took too long and hit the deadline or\n    // number of diffs equals number of characters, no commonality at all.\n    return [[DiffOp.Delete, text1], [DiffOp.Insert, text2]];\n  };\n\n\n  /**\n   * Given the location of the 'middle snake', split the diff in two parts\n   * and recurse.\n   * @param  text1 Old string to be diffed.\n   * @param  text2 New string to be diffed.\n   * @param  x Index of split point in text1.\n   * @param  y Index of split point in text2.\n   * @param  deadline Time at which to bail if not yet complete.\n   * @return  Array of diff tuples.\n\n   */\n    diff_bisectSplit_ (text1: string, text2: string, x: number, y: number, deadline: number) {\n      const text1a = text1.substring(0, x);\n      const text2a = text2.substring(0, y);\n      const text1b = text1.substring(x);\n      const text2b = text2.substring(y);\n\n      // Compute both diffs serially.\n      const diffs = this.diff_main(text1a, text2a, false, deadline);\n      const diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n      return diffs.concat(diffsb);\n    };\n\n\n  /**\n   * Split two texts into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * @param  text1 First string.\n   * @param  text2 Second string.\n   * @return }\n   *     An object containing the encoded text1, the encoded text2 and\n   *     the array of unique strings.\n   *     The zeroth element of the array of unique strings is intentionally blank.\n\n   */\n    diff_linesToChars_ (text1: string, text2: string) {\n      const lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n      const lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n      // '\\x00' is a valid character, but constious debuggers don't like it.\n      // So we'll insert a junk entry to avoid generating a null character.\n      lineArray[0] = '';\n\n\n      const chars1 = this.diff_linesToCharsMunge_(text1, lineArray, lineHash);\n      const chars2 = this.diff_linesToCharsMunge_(text2, lineArray, lineHash);\n      return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n   };\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param  text String to encode.\n   * @return  Encoded string.\n\n   */\n  diff_linesToCharsMunge_(text: string, lineArray: Array<string>, lineHash: any): string {\n    let chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    let lineStart = 0;\n    let lineEnd = -1;\n    // Keeping our own length constiable is faster than looking it up.\n    let lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      const line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  /**\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\n   * text.\n   * @param  diffs Array of diff tuples.\n   * @param  lineArray Array of unique strings.\n\n   */\n    diff_charsToLines_ (diffs: Array<Diff>, lineArray: Array<string>): void {\n    for (let x = 0; x < diffs.length; x++) {\n      const chars = diffs[x][1];\n      const text = [];\n      for (let y = 0; y < chars.length; y++) {\n        text[y] = lineArray[chars.charCodeAt(y)];\n      }\n      diffs[x][1] = text.join('');\n    }\n  };\n\n\n  /**\n   * Determine the common prefix of two strings.\n   * @param  text1 First string.\n   * @param  text2 Second string.\n   * @return  The number of characters common to the start of each\n   *     string.\n   */\n    diff_commonPrefix (text1: string, text2: string): number {\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n      return 0;\n    }\n    // Binary search.\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n    let pointermin = 0;\n    let pointermax = Math.min(text1.length, text2.length);\n    let pointermid = pointermax;\n    let pointerstart = 0;\n    while (pointermin < pointermid) {\n      if (text1.substring(pointerstart, pointermid) ==\n          text2.substring(pointerstart, pointermid)) {\n        pointermin = pointermid;\n        pointerstart = pointermin;\n      } else {\n        pointermax = pointermid;\n      }\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n  };\n\n\n  /**\n   * Determine the common suffix of two strings.\n   * @param  text1 First string.\n   * @param  text2 Second string.\n   * @return  The number of characters common to the end of each string.\n   */\n    diff_commonSuffix (text1: string, text2: string): number {\n    // Quick check for common null cases.\n    if (!text1 || !text2 ||\n        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n      return 0;\n    }\n    // Binary search.\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n    let pointermin = 0;\n    let pointermax = Math.min(text1.length, text2.length);\n    let pointermid = pointermax;\n    let pointerend = 0;\n    while (pointermin < pointermid) {\n      if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n          text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n        pointermin = pointermid;\n        pointerend = pointermin;\n      } else {\n        pointermax = pointermid;\n      }\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n  };\n\n\n  /**\n   * Determine if the suffix of one string is the prefix of another.\n   * @param  text1 First string.\n   * @param  text2 Second string.\n   * @return  The number of characters common to the end of the first\n   *     string and the start of the second string.\n\n   */\n    diff_commonOverlap_ (text1: string, text2: string): number {\n    // Cache the text lengths to prevent multiple calls.\n    const text1_length = text1.length;\n    const text2_length = text2.length;\n    // Eliminate the null case.\n    if (text1_length == 0 || text2_length == 0) {\n      return 0;\n    }\n    // Truncate the longer string.\n    if (text1_length > text2_length) {\n      text1 = text1.substring(text1_length - text2_length);\n    } else if (text1_length < text2_length) {\n      text2 = text2.substring(0, text1_length);\n    }\n    const text_length = Math.min(text1_length, text2_length);\n    // Quick check for the worst case.\n    if (text1 == text2) {\n      return text_length;\n    }\n\n    // Start by looking for a single character match\n    // and increase length until no match is found.\n    // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n    let best = 0;\n    let length = 1;\n    while (true) {\n      const pattern = text1.substring(text_length - length);\n      const found = text2.indexOf(pattern);\n      if (found == -1) {\n        return best;\n      }\n      length += found;\n      if (found == 0 || text1.substring(text_length - length) ==\n          text2.substring(0, length)) {\n        best = length;\n        length++;\n      }\n    }\n  };\n\n\n  /**\n   * Do the two texts share a substring which is at least half the length of the\n   * longer text?\n   * This speedup can produce non-minimal diffs.\n   * @param  text1 First string.\n   * @param  text2 Second string.\n   * @return  Five element Array, containing the prefix of\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\n   *     text2 and the common middle.  Or null if there was no match.\n\n   */\n    diff_halfMatch_ (text1: string, text2: string) {\n    if (this.Diff_Timeout <= 0) {\n      // Don't risk returning a non-optimal diff if we have unlimited time.\n      return null;\n    }\n    const longtext = text1.length > text2.length ? text1 : text2;\n    const shorttext = text1.length > text2.length ? text2 : text1;\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n      return null;  // Pointless.\n    }\n    const dmp = this;  // 'this' becomes 'window' in a closure.\n\n\n    // First check if the second quarter is the seed for a half-match.\n    const hm1 = this.diff_halfMatchI_(longtext, shorttext,\n                              Math.ceil(longtext.length / 4), dmp);\n    // Check again based on the third quarter.\n    const hm2 = this.diff_halfMatchI_(longtext, shorttext,\n                              Math.ceil(longtext.length / 2), dmp);\n    let hm;\n    if (!hm1 && !hm2) {\n      return null;\n    } else if (!hm2) {\n      hm = hm1;\n    } else if (!hm1) {\n      hm = hm2;\n    } else {\n      // Both matched.  Select the longest.\n      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n    }\n\n    // A half-match was found, sort out the return data.\n    let text1_a, text1_b, text2_a, text2_b;\n    if (text1.length > text2.length) {\n      text1_a = hm[0];\n      text1_b = hm[1];\n      text2_a = hm[2];\n      text2_b = hm[3];\n    } else {\n      text2_a = hm[0];\n      text2_b = hm[1];\n      text1_a = hm[2];\n      text1_b = hm[3];\n    }\n    const mid_common = hm[4];\n    return [text1_a, text1_b, text2_a, text2_b, mid_common];\n  };\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external constiables.\n   * @param  longtext Longer string.\n   * @param  shorttext Shorter string.\n   * @param  i Start index of quarter length substring within longtext.\n   * @return  Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n\n   */\n  diff_halfMatchI_(longtext: string, shorttext: string, i: number, dmp: DiffMatchPatch): Array<string> {\n    // Start with a 1/4 length substring at position i as a seed.\n    const seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    let j = -1;\n    let best_common = '';\n    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      const prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                              shorttext.substring(j));\n      const suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                              shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Reduce the number of edits by eliminating semantically trivial equalities.\n   * @param  diffs Array of diff tuples.\n   */\n    diff_cleanupSemantic (diffs: Array<Diff>) {\n    let changes = false;\n    const equalities = [];  // Stack of indices where equalities are found.\n    let equalitiesLength = 0;  // Keeping our own length const is faster in JS.\n\n    let lastequality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    let pointer = 0;  // Index of current position.\n    // Number of characters that changed prior to the equality.\n    let length_insertions1 = 0;\n    let length_deletions1 = 0;\n    // Number of characters that changed after the equality.\n    let length_insertions2 = 0;\n    let length_deletions2 = 0;\n    while (pointer < diffs.length) {\n      if (diffs[pointer][0] == DiffOp.Equal) {  // Equality found.\n        equalities[equalitiesLength++] = pointer;\n        length_insertions1 = length_insertions2;\n        length_deletions1 = length_deletions2;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = diffs[pointer][1];\n      } else {  // An insertion or deletion.\n        if (diffs[pointer][0] == DiffOp.Insert) {\n          length_insertions2 += diffs[pointer][1].length;\n        } else {\n          length_deletions2 += diffs[pointer][1].length;\n        }\n        // Eliminate an equality that is smaller or equal to the edits on both\n        // sides of it.\n        if (lastequality && (lastequality.length <=\n            Math.max(length_insertions1, length_deletions1)) &&\n            (lastequality.length <= Math.max(length_insertions2,\n                                            length_deletions2))) {\n          // Duplicate record.\n          diffs.splice(equalities[equalitiesLength - 1], 0,\n                      [DiffOp.Delete, lastequality]);\n          // Change second copy to insert.\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\n          // Throw away the equality we just deleted.\n          equalitiesLength--;\n          // Throw away the previous equality (it needs to be reevaluated).\n          equalitiesLength--;\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n          length_insertions1 = 0;  // Reset the counters.\n          length_deletions1 = 0;\n          length_insertions2 = 0;\n          length_deletions2 = 0;\n          lastequality = null;\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n\n    // Normalize the diff.\n    if (changes) {\n      this.diff_cleanupMerge(diffs);\n    }\n    this.diff_cleanupSemanticLossless(diffs);\n\n    // Find any overlaps between deletions and insertions.\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n    //   -> <del>abc</del>xxx<ins>def</ins>\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n    //   -> <ins>def</ins>xxx<del>abc</del>\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\n    pointer = 1;\n    while (pointer < diffs.length) {\n      if (diffs[pointer - 1][0] == DiffOp.Delete &&\n          diffs[pointer][0] == DiffOp.Insert) {\n        const deletion = diffs[pointer - 1][1];\n        const insertion = diffs[pointer][1];\n        const overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n        const overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n        if (overlap_length1 >= overlap_length2) {\n          if (overlap_length1 >= deletion.length / 2 ||\n              overlap_length1 >= insertion.length / 2) {\n            // Overlap found.  Insert an equality and trim the surrounding edits.\n            diffs.splice(pointer, 0,\n                [DiffOp.Equal, insertion.substring(0, overlap_length1)]);\n            diffs[pointer - 1][1] =\n                deletion.substring(0, deletion.length - overlap_length1);\n            diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n            pointer++;\n          }\n        } else {\n          if (overlap_length2 >= deletion.length / 2 ||\n              overlap_length2 >= insertion.length / 2) {\n            // Reverse overlap found.\n            // Insert an equality and swap and trim the surrounding edits.\n            diffs.splice(pointer, 0,\n                [DiffOp.Equal, deletion.substring(0, overlap_length2)]);\n            diffs[pointer - 1][0] = DiffOp.Insert;\n            diffs[pointer - 1][1] =\n                insertion.substring(0, insertion.length - overlap_length2);\n            diffs[pointer + 1][0] = DiffOp.Delete;\n            diffs[pointer + 1][1] =\n                deletion.substring(overlap_length2);\n            pointer++;\n          }\n        }\n        pointer++;\n      }\n      pointer++;\n    }\n  };\n\n\n  /**\n   * Look for single edits surrounded on both sides by equalities\n   * which can be shifted sideways to align the edit to a word boundary.\n   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n   * @param  diffs Array of diff tuples.\n   */\n    diff_cleanupSemanticLossless (diffs: Array<Diff>) {\n    /**\n     * Given two strings, compute a score representing whether the internal\n     * boundary falls on logical boundaries.\n     * Scores range from 6 (best) to 0 (worst).\n     * Closure, but does not reference any external constiables.\n     * @param  one First string.\n     * @param  two Second string.\n     * @return  The score.\n\n     */\n    function diff_cleanupSemanticScore_(one: string, two: string): number {\n      if (!one || !two) {\n        // Edges are the best.\n        return 6;\n      }\n\n\n      const nonAlphaNumericRegex_ = new RegExp('/[^a-zA-Z0-9]/');\n\n      // Each port of this function behaves slightly differently due to\n      // subtle differences in each language's definition of things like\n      // 'whitespace'.  Since this function's purpose is largely cosmetic,\n      // the choice has been made to use each language's native features\n      // rather than force total conformity.\n      const char1 = one.charAt(one.length - 1);\n      const char2 = two.charAt(0);\n      const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n      const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n      const whitespace1 = nonAlphaNumeric1 &&\n          char1.match(this.whitespaceRegex_);\n      const whitespace2 = nonAlphaNumeric2 &&\n          char2.match(this.whitespaceRegex_);\n      const lineBreak1 = whitespace1 &&\n          char1.match(this.linebreakRegex_);\n      const lineBreak2 = whitespace2 &&\n          char2.match(this.linebreakRegex_);\n      const blankLine1 = lineBreak1 &&\n          one.match(this.blanklineEndRegex_);\n      const blankLine2 = lineBreak2 &&\n          two.match(this.blanklineStartRegex_);\n\n      if (blankLine1 || blankLine2) {\n        // Five points for blank lines.\n        return 5;\n      } else if (lineBreak1 || lineBreak2) {\n        // Four points for line breaks.\n        return 4;\n      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n        // Three points for end of sentences.\n        return 3;\n      } else if (whitespace1 || whitespace2) {\n        // Two points for whitespace.\n        return 2;\n      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n        // One point for non-alphanumeric.\n        return 1;\n      }\n      return 0;\n    }\n\n    let pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n      if (diffs[pointer - 1][0] == DiffOp.Equal &&\n          diffs[pointer + 1][0] == DiffOp.Equal) {\n        // This is a single edit surrounded by equalities.\n        let equality1 = diffs[pointer - 1][1];\n        let edit = diffs[pointer][1];\n        let equality2 = diffs[pointer + 1][1];\n\n        // First, shift the edit as far left as possible.\n        const commonOffset = this.diff_commonSuffix(equality1, edit);\n        if (commonOffset) {\n          const commonString = edit.substring(edit.length - commonOffset);\n          equality1 = equality1.substring(0, equality1.length - commonOffset);\n          edit = commonString + edit.substring(0, edit.length - commonOffset);\n          equality2 = commonString + equality2;\n        }\n\n        // Second, step character by character right, looking for the best fit.\n        let bestEquality1 = equality1;\n        let bestEdit = edit;\n        let bestEquality2 = equality2;\n        let bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        while (edit.charAt(0) === equality2.charAt(0)) {\n          equality1 += edit.charAt(0);\n          edit = edit.substring(1) + equality2.charAt(0);\n          equality2 = equality2.substring(1);\n          const score = diff_cleanupSemanticScore_(equality1, edit) +\n              diff_cleanupSemanticScore_(edit, equality2);\n          // The >= encourages trailing rather than leading whitespace on edits.\n          if (score >= bestScore) {\n            bestScore = score;\n            bestEquality1 = equality1;\n            bestEdit = edit;\n            bestEquality2 = equality2;\n          }\n        }\n\n        if (diffs[pointer - 1][1] != bestEquality1) {\n          // We have an improvement, save it back to the diff.\n          if (bestEquality1) {\n            diffs[pointer - 1][1] = bestEquality1;\n          } else {\n            diffs.splice(pointer - 1, 1);\n            pointer--;\n          }\n          diffs[pointer][1] = bestEdit;\n          if (bestEquality2) {\n            diffs[pointer + 1][1] = bestEquality2;\n          } else {\n            diffs.splice(pointer + 1, 1);\n            pointer--;\n          }\n        }\n      }\n      pointer++;\n    }\n  };\n\n\n  /**\n   * Reduce the number of edits by eliminating operationally trivial equalities.\n   * @param  diffs Array of diff tuples.\n   */\n    diff_cleanupEfficiency (diffs: Array<Diff>) {\n    let changes = false;\n    const equalities = [];  // Stack of indices where equalities are found.\n    let equalitiesLength = 0;  // Keeping our own length const is faster in JS.\n\n    let lastequality = null;\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    let pointer = 0;  // Index of current position.\n    // Is there an insertion operation before the last equality.\n    let pre_ins = false;\n    // Is there a deletion operation before the last equality.\n    let pre_del = false;\n    // Is there an insertion operation after the last equality.\n    let post_ins = false;\n    // Is there a deletion operation after the last equality.\n    let post_del = false;\n    while (pointer < diffs.length) {\n      if (diffs[pointer][0] == DiffOp.Equal) {  // Equality found.\n        if (diffs[pointer][1].length < this.Diff_EditCost &&\n            (post_ins || post_del)) {\n          // Candidate found.\n          equalities[equalitiesLength++] = pointer;\n          pre_ins = post_ins;\n          pre_del = post_del;\n          lastequality = diffs[pointer][1];\n        } else {\n          // Not a candidate, and can never become one.\n          equalitiesLength = 0;\n          lastequality = null;\n        }\n        post_ins = post_del = false;\n      } else {  // An insertion or deletion.\n        if (diffs[pointer][0] == DiffOp.Delete) {\n          post_del = true;\n        } else {\n          post_ins = true;\n        }\n        /*\n        * Five types to be split:\n        * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n        * <ins>A</ins>X<ins>C</ins><del>D</del>\n        * <ins>A</ins><del>B</del>X<ins>C</ins>\n        * <ins>A</del>X<ins>C</ins><del>D</del>\n        * <ins>A</ins><del>B</del>X<del>C</del>\n        */\n        if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                            ((lastequality.length < this.Diff_EditCost / 2) &&\n                            ((pre_ins?1:0) + (pre_del?1:0) + (post_ins?1:0) + (post_del?1:0) == 3)))) {\n          // Duplicate record.\n          diffs.splice(equalities[equalitiesLength - 1], 0,\n                      [DiffOp.Delete, lastequality]);\n          // Change second copy to insert.\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\n          equalitiesLength--;  // Throw away the equality we just deleted;\n          lastequality = null;\n          if (pre_ins && pre_del) {\n            // No changes made which could affect previous entry, keep going.\n            post_ins = post_del = true;\n            equalitiesLength = 0;\n          } else {\n            equalitiesLength--;  // Throw away the previous equality.\n            pointer = equalitiesLength > 0 ?\n                equalities[equalitiesLength - 1] : -1;\n            post_ins = post_del = false;\n          }\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n\n    if (changes) {\n      this.diff_cleanupMerge(diffs);\n    }\n  };\n\n\n  /**\n   * Reorder and merge like edit sections.  Merge equalities.\n   * Any edit section can move as long as it doesn't cross an equality.\n   * @param  diffs Array of diff tuples.\n   */\n    diff_cleanupMerge (diffs: Array<Diff>) {\n    diffs.push([DiffOp.Equal, '']);  // Add a dummy entry at the end.\n    let pointer = 0;\n    let count_delete = 0;\n    let count_insert = 0;\n    let text_delete = '';\n    let text_insert = '';\n    let commonlength;\n    while (pointer < diffs.length) {\n      switch (diffs[pointer][0]) {\n        case DiffOp.Insert:\n          count_insert++;\n          text_insert += diffs[pointer][1];\n          pointer++;\n          break;\n        case DiffOp.Delete:\n          count_delete++;\n          text_delete += diffs[pointer][1];\n          pointer++;\n          break;\n        case DiffOp.Equal:\n          // Upon reaching an equality, check for prior redundancies.\n          if (count_delete + count_insert > 1) {\n            if (count_delete !== 0 && count_insert !== 0) {\n              // Factor out any common prefixies.\n              commonlength = this.diff_commonPrefix(text_insert, text_delete);\n              if (commonlength !== 0) {\n                if ((pointer - count_delete - count_insert) > 0 &&\n                    diffs[pointer - count_delete - count_insert - 1][0] ==\n                    DiffOp.Equal) {\n                  diffs[pointer - count_delete - count_insert - 1][1] +=\n                      text_insert.substring(0, commonlength);\n                } else {\n                  diffs.splice(0, 0, [DiffOp.Equal,\n                                      text_insert.substring(0, commonlength)]);\n                  pointer++;\n                }\n                text_insert = text_insert.substring(commonlength);\n                text_delete = text_delete.substring(commonlength);\n              }\n              // Factor out any common suffixies.\n              commonlength = this.diff_commonSuffix(text_insert, text_delete);\n              if (commonlength !== 0) {\n                diffs[pointer][1] = text_insert.substring(text_insert.length -\n                    commonlength) + diffs[pointer][1];\n                text_insert = text_insert.substring(0, text_insert.length -\n                    commonlength);\n                text_delete = text_delete.substring(0, text_delete.length -\n                    commonlength);\n              }\n            }\n            // Delete the offending records and add the merged ones.\n            if (count_delete === 0) {\n              diffs.splice(pointer - count_insert,\n                  count_delete + count_insert, [DiffOp.Insert, text_insert]);\n            } else if (count_insert === 0) {\n              diffs.splice(pointer - count_delete,\n                  count_delete + count_insert, [DiffOp.Delete, text_delete]);\n            } else {\n              diffs.splice(pointer - count_delete - count_insert,\n                  count_delete + count_insert, [DiffOp.Delete, text_delete],\n                  [DiffOp.Insert, text_insert]);\n            }\n            pointer = pointer - count_delete - count_insert +\n                      (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n          } else if (pointer !== 0 && diffs[pointer - 1][0] == DiffOp.Equal) {\n            // Merge this equality with the previous one.\n            diffs[pointer - 1][1] += diffs[pointer][1];\n            diffs.splice(pointer, 1);\n          } else {\n            pointer++;\n          }\n          count_insert = 0;\n          count_delete = 0;\n          text_delete = '';\n          text_insert = '';\n          break;\n      }\n    }\n    if (diffs[diffs.length - 1][1] === '') {\n      diffs.pop();  // Remove the dummy entry at the end.\n    }\n\n    // Second pass: look for single edits surrounded on both sides by equalities\n    // which can be shifted sideways to eliminate an equality.\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n    let changes = false;\n    pointer = 1;\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n      if (diffs[pointer - 1][0] == DiffOp.Equal &&\n          diffs[pointer + 1][0] == DiffOp.Equal) {\n        // This is a single edit surrounded by equalities.\n        if (diffs[pointer][1].substring(diffs[pointer][1].length -\n            diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n          // Shift the edit over the previous equality.\n          diffs[pointer][1] = diffs[pointer - 1][1] +\n              diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                          diffs[pointer - 1][1].length);\n          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n          diffs.splice(pointer - 1, 1);\n          changes = true;\n        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n            diffs[pointer + 1][1]) {\n          // Shift the edit over the next equality.\n          diffs[pointer - 1][1] += diffs[pointer + 1][1];\n          diffs[pointer][1] =\n              diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n              diffs[pointer + 1][1];\n          diffs.splice(pointer + 1, 1);\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n    // If shifts were made, the diff needs reordering and another shift sweep.\n    if (changes) {\n      this.diff_cleanupMerge(diffs);\n    }\n  };\n\n\n  /**\n   * loc is a location in text1, compute and return the equivalent location in\n   * text2.\n   * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n   * @param  diffs Array of diff tuples.\n   * @param  loc Location within text1.\n   * @return  Location within text2.\n   */\n    diff_xIndex (diffs: Array<Diff>, loc: number): number {\n    let chars1 = 0;\n    let chars2 = 0;\n    let last_chars1 = 0;\n    let last_chars2 = 0;\n    let x;\n    for (x = 0; x < diffs.length; x++) {\n      if (diffs[x][0] !== DiffOp.Insert) {  // Equality or deletion.\n        chars1 += diffs[x][1].length;\n      }\n      if (diffs[x][0] !== DiffOp.Delete) {  // Equality or insertion.\n        chars2 += diffs[x][1].length;\n      }\n      if (chars1 > loc) {  // Overshot the location.\n        break;\n      }\n      last_chars1 = chars1;\n      last_chars2 = chars2;\n    }\n    // Was the location was deleted?\n    if (diffs.length != x && diffs[x][0] === DiffOp.Delete) {\n      return last_chars2;\n    }\n    // Add the remaining character length.\n    return last_chars2 + (loc - last_chars1);\n  };\n\n\n  /**\n   * Convert a diff array into a pretty HTML report.\n   * @param  diffs Array of diff tuples.\n   * @return  HTML representation.\n   */\n    diff_prettyHtml = function(diffs: Array<Diff>): string {\n    const html = [];\n    const pattern_amp = /&/g;\n    const pattern_lt = /</g;\n    const pattern_gt = />/g;\n    const pattern_para = /\\n/g;\n    for (let x = 0; x < diffs.length; x++) {\n      const op = diffs[x][0];    // Operation (insert, delete, equal)\n      const data = diffs[x][1];  // Text of change.\n      const text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n          .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n      switch (op) {\n        case DiffOp.Insert:\n          html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n          break;\n        case DiffOp.Delete:\n          html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n          break;\n        case DiffOp.Equal:\n          html[x] = '<span>' + text + '</span>';\n          break;\n      }\n    }\n    return html.join('');\n  };\n\n\n  /**\n   * Compute and return the source text (all equalities and deletions).\n   * @param  diffs Array of diff tuples.\n   * @return  Source text.\n   */\n    diff_text1 (diffs: Array<Diff>): string {\n    const text = [];\n    for (let x = 0; x < diffs.length; x++) {\n      if (diffs[x][0] !== DiffOp.Insert) {\n        text[x] = diffs[x][1];\n      }\n    }\n    return text.join('');\n  };\n\n\n  /**\n   * Compute and return the destination text (all equalities and insertions).\n   * @param  diffs Array of diff tuples.\n   * @return  Destination text.\n   */\n    diff_text2 (diffs: Array<Diff>): string {\n    const text = [];\n    for (let x = 0; x < diffs.length; x++) {\n      if (diffs[x][0] !== DiffOp.Delete) {\n        text[x] = diffs[x][1];\n      }\n    }\n    return text.join('');\n  };\n\n\n  /**\n   * Compute the Levenshtein distance; the number of inserted, deleted or\n   * substituted characters.\n   * @param  diffs Array of diff tuples.\n   * @return  Number of changes.\n   */\n    diff_levenshtein (diffs: Array<Diff>): number {\n    let levenshtein = 0;\n    let insertions = 0;\n    let deletions = 0;\n    for (let x = 0; x < diffs.length; x++) {\n      const op = diffs[x][0];\n      const data = diffs[x][1];\n      switch (op) {\n        case DiffOp.Insert:\n          insertions += data.length;\n          break;\n        case DiffOp.Delete:\n          deletions += data.length;\n          break;\n        case DiffOp.Equal:\n          // A deletion and an insertion is one substitution.\n          levenshtein += Math.max(insertions, deletions);\n          insertions = 0;\n          deletions = 0;\n          break;\n      }\n    }\n    levenshtein += Math.max(insertions, deletions);\n    return levenshtein;\n  };\n\n\n  /**\n   * Crush the diff into an encoded string which describes the operations\n   * required to transform text1 into text2.\n   * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n   * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n   * @param  diffs Array of diff tuples.\n   * @return  Delta text.\n   */\n    diff_toDelta (diffs: Array<Diff>): string {\n    const text = [];\n    for (let x = 0; x < diffs.length; x++) {\n      switch (diffs[x][0]) {\n        case DiffOp.Insert:\n          text[x] = '+' + encodeURI(diffs[x][1]);\n          break;\n        case DiffOp.Delete:\n          text[x] = '-' + diffs[x][1].length;\n          break;\n        case DiffOp.Equal:\n          text[x] = '=' + diffs[x][1].length;\n          break;\n      }\n    }\n    return text.join('\\t').replace(/%20/g, ' ');\n  };\n\n\n  /**\n   * Given the original text1, and an encoded string which describes the\n   * operations required to transform text1 into text2, compute the full diff.\n   * @param  text1 Source string for the diff.\n   * @param  delta Delta text.\n   * @return  Array of diff tuples.\n   * @throws {!Error} If invalid input.\n   */\n    diff_fromDelta (text1: string, delta: string) {\n    const diffs = [];\n    let diffsLength = 0;  // Keeping our own length const is faster in JS.\n    let pointer = 0;  // Cursor in text1\n    const tokens = delta.split(/\\t/g);\n    for (let x = 0; x < tokens.length; x++) {\n      // Each token begins with a one character parameter which specifies the\n      // operation of this token (delete, insert, equality).\n      const param = tokens[x].substring(1);\n      switch (tokens[x].charAt(0)) {\n        case '+':\n          try {\n            diffs[diffsLength++] = [DiffOp.Insert, decodeURI(param)];\n          } catch (ex) {\n            // Malformed URI sequence.\n            throw new Error('Illegal escape in diff_fromDelta: ' + param);\n          }\n          break;\n        case '-':\n          // Fall through.\n        case '=':\n          const n = parseInt(param, 10);\n          if (isNaN(n) || n < 0) {\n            throw new Error('Invalid number in diff_fromDelta: ' + param);\n          }\n          const text = text1.substring(pointer, pointer += n);\n          if (tokens[x].charAt(0) == '=') {\n            diffs[diffsLength++] = [DiffOp.Equal, text];\n          } else {\n            diffs[diffsLength++] = [DiffOp.Delete, text];\n          }\n          break;\n        default:\n          // Blank tokens are ok (from a trailing \\t).\n          // Anything else is an error.\n          if (tokens[x]) {\n            throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                            tokens[x]);\n          }\n      }\n    }\n    if (pointer != text1.length) {\n      throw new Error('Delta length (' + pointer +\n          ') does not equal source text length (' + text1.length + ').');\n    }\n    return diffs;\n  };\n\n  /**\n   * Locate the best instance of 'pattern' in 'text' near 'loc'.\n   * @param  text The text to search.\n   * @param  pattern The pattern to search for.\n   * @param  loc The location to search around.\n   * @return  Best match index or -1.\n   */\n    match_main (text: string, pattern: string, loc: number): number {\n    // Check for null inputs.\n    if (text == null || pattern == null || loc == null) {\n      throw new Error('Null input. (match_main)');\n    }\n\n    loc = Math.max(0, Math.min(loc, text.length));\n    if (text == pattern) {\n      // Shortcut (potentially not guaranteed by the algorithm)\n      return 0;\n    } else if (!text.length) {\n      // Nothing to match.\n      return -1;\n    } else if (text.substring(loc, loc + pattern.length) == pattern) {\n      // Perfect match at the perfect spot!  (Includes case of null pattern)\n      return loc;\n    } else {\n      // Do a fuzzy compare.\n      return this.match_bitap_(text, pattern, loc);\n    }\n  };\n\n\n  /**\n   * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n   * Bitap algorithm.\n   * @param  text The text to search.\n   * @param  pattern The pattern to search for.\n   * @param  loc The location to search around.\n   * @return  Best match index or -1.\n\n   */\n    match_bitap_ (text: string, pattern: string, loc: number): number {\n    if (pattern.length > this.Match_MaxBits) {\n      throw new Error('Pattern too long for this browser.');\n    }\n\n    // Initialise the alphabet.\n    const s = this.match_alphabet_(pattern);\n\n    const dmp = this;  // 'this' becomes 'window' in a closure.\n\n    /**\n     * Compute and return the score for a match with e errors and x location.\n     * Accesses loc and pattern through being a closure.\n     * @param  e Number of errors in match.\n     * @param  x Location of match.\n     * @return  Overall score for match (0.0 = good, 1.0 = bad).\n\n     */\n    function match_bitapScore_(e: number, x: number): number {\n      const accuracy = e / pattern.length;\n      const proximity = Math.abs(loc - x);\n      if (!dmp.Match_Distance) {\n        // Dodge divide by zero error.\n        return proximity ? 1.0 : accuracy;\n      }\n      return accuracy + (proximity / dmp.Match_Distance);\n    }\n\n    // Highest score beyond which we give up.\n    let score_threshold = this.Match_Threshold;\n    // Is there a nearby exact match? (speedup)\n    let best_loc = text.indexOf(pattern, loc);\n    if (best_loc != -1) {\n      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n      // What about in the other direction? (speedup)\n      best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n      if (best_loc != -1) {\n        score_threshold =\n            Math.min(match_bitapScore_(0, best_loc), score_threshold);\n      }\n    }\n\n    // Initialise the bit arrays.\n    const matchmask = 1 << (pattern.length - 1);\n    best_loc = -1;\n\n    let bin_min, bin_mid;\n    let bin_max = pattern.length + text.length;\n    let last_rd;\n    for (let d = 0; d < pattern.length; d++) {\n      // Scan for the best match; each iteration allows for one more error.\n      // Run a binary search to determine how far from 'loc' we can stray at this\n      // error level.\n      bin_min = 0;\n      bin_mid = bin_max;\n      while (bin_min < bin_mid) {\n        if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n          bin_min = bin_mid;\n        } else {\n          bin_max = bin_mid;\n        }\n        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n      }\n      // Use the result from this iteration as the maximum for the next.\n      bin_max = bin_mid;\n      let start = Math.max(1, loc - bin_mid + 1);\n      const finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n      const rd = Array(finish + 2);\n      rd[finish + 1] = (1 << d) - 1;\n      for (let j = finish; j >= start; j--) {\n        // The alphabet (s) is a sparse hash, so the following line generates\n        // warnings.\n        const charMatch = s[text.charAt(j - 1)];\n        if (d === 0) {  // First pass: exact match.\n          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n        } else {  // Subsequent passes: fuzzy match.\n          rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                  (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                  last_rd[j + 1];\n        }\n        if (rd[j] & matchmask) {\n          const score = match_bitapScore_(d, j - 1);\n          // This match will almost certainly be better than any existing match.\n          // But check anyway.\n          if (score <= score_threshold) {\n            // Told you so.\n            score_threshold = score;\n            best_loc = j - 1;\n            if (best_loc > loc) {\n              // When passing loc, don't exceed our current distance from loc.\n              start = Math.max(1, 2 * loc - best_loc);\n            } else {\n              // Already passed loc, downhill from here on in.\n              break;\n            }\n          }\n        }\n      }\n      // No hope for a (better) match at greater error levels.\n      if (match_bitapScore_(d + 1, loc) > score_threshold) {\n        break;\n      }\n      last_rd = rd;\n    }\n    return best_loc;\n  };\n\n\n  /**\n   * Initialise the alphabet for the Bitap algorithm.\n   * @param  pattern The text to encode.\n   * @return  Hash of character locations.\n\n   */\n    match_alphabet_ (pattern: string): { [character: string]: number } {\n    const s: { [character: string]: number } = {};\n    for (let i = 0; i < pattern.length; i++) {\n      s[pattern.charAt(i)] = 0;\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n    }\n    return s;\n  };\n\n\n  /**\n   * Increase the context until it is unique,\n   * but don't let the pattern expand beyond Match_MaxBits.\n   * @param  patch The patch to grow.\n   * @param  text Source text.\n\n   */\n    patch_addContext_ (patch: patch_obj, text: string) {\n    if (text.length == 0) {\n      return;\n    }\n    let pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n    let padding = 0;\n\n    // Look for the first and last matches of pattern in text.  If two different\n    // matches are found, increase the pattern length.\n    while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n          pattern.length < this.Match_MaxBits - this.Patch_Margin -\n          this.Patch_Margin) {\n      padding += this.Patch_Margin;\n      pattern = text.substring(patch.start2 - padding,\n                              patch.start2 + patch.length1 + padding);\n    }\n    // Add one chunk for good luck.\n    padding += this.Patch_Margin;\n\n    // Add the prefix.\n    const prefix = text.substring(patch.start2 - padding, patch.start2);\n    if (prefix) {\n      patch.diffs.unshift([DiffOp.Equal, prefix]);\n    }\n    // Add the suffix.\n    const suffix = text.substring(patch.start2 + patch.length1,\n                                patch.start2 + patch.length1 + padding);\n    if (suffix) {\n      patch.diffs.push([DiffOp.Equal, suffix]);\n    }\n\n    // Roll back the start points.\n    patch.start1 -= prefix.length;\n    patch.start2 -= prefix.length;\n    // Extend the lengths.\n    patch.length1 += prefix.length + suffix.length;\n    patch.length2 += prefix.length + suffix.length;\n  };\n\n\n  /**\n   * Compute a list of patches to turn text1 into text2.\n   * Use diffs if provided, otherwise compute it ourselves.\n   * There are four ways to call this function, depending on what data is\n   * available to the caller:\n   * Method 1:\n   * a = text1, b = text2\n   * Method 2:\n   * a = diffs\n   * Method 3 (optimal):\n   * a = text1, b = diffs\n   * Method 4 (deprecated, use method 3):\n   * a = text1, b = text2, c = diffs\n   *\n   * @param  a text1 (methods 1,3,4) or\n   * Array of diff tuples for text1 to text2 (method 2).\n   * @param  opt_b text2 (methods 1,4) or\n   * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n   * @param  opt_c Array of diff tuples\n   * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n   * @return  Array of Patch objects.\n   */\n    patch_make (a: string | Array<Diff>, opt_b: string | Array<Diff>, opt_c: string | Array<Diff>) {\n    let text1, diffs;\n    if (typeof a == 'string' && typeof opt_b == 'string' &&\n        typeof opt_c == 'undefined') {\n      // Method 1: text1, text2\n      // Compute diffs from text1 and text2.\n      text1 = (a);\n      diffs = this.diff_main(text1, (opt_b), true);\n      if (diffs.length > 2) {\n        this.diff_cleanupSemantic(diffs);\n        this.diff_cleanupEfficiency(diffs);\n      }\n    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n        typeof opt_c == 'undefined') {\n      // Method 2: diffs\n      // Compute text1 from diffs.\n      diffs = (a);\n      text1 = this.diff_text1(diffs);\n    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n        typeof opt_c == 'undefined') {\n      // Method 3: text1, diffs\n      text1 = (a);\n      diffs = (opt_b);\n    } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n        opt_c && typeof opt_c == 'object') {\n      // Method 4: text1, text2, diffs\n      // text2 is not used.\n      text1 = (a);\n      diffs = (opt_c);\n    } else {\n      throw new Error('Unknown call format to patch_make.');\n    }\n\n    if (diffs.length === 0) {\n      return [];  // Get rid of the null case.\n    }\n    const patches = [];\n    let patch = new patch_obj();\n    let patchDiffLength = 0;  // Keeping our own length const is faster in JS.\n    let char_count1 = 0;  // Number of characters into the text1 string.\n    let char_count2 = 0;  // Number of characters into the text2 string.\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n    // text2 (postpatch_text).  We recreate the patches one by one to determine\n    // context info.\n    let prepatch_text = text1;\n    let postpatch_text = text1;\n    for (let x = 0; x < diffs.length; x++) {\n      const diff_type = diffs[x][0];\n      const diff_text = diffs[x][1];\n\n      if (!patchDiffLength && diff_type !== DiffOp.Equal) {\n        // A new patch starts here.\n        patch.start1 = char_count1;\n        patch.start2 = char_count2;\n      }\n\n      switch (diff_type) {\n        case DiffOp.Insert:\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length2 += diff_text.length;\n          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                          postpatch_text.substring(char_count2);\n          break;\n        case DiffOp.Delete:\n          patch.length1 += diff_text.length;\n          patch.diffs[patchDiffLength++] = diffs[x];\n          postpatch_text = postpatch_text.substring(0, char_count2) +\n                          postpatch_text.substring(char_count2 +\n                              diff_text.length);\n          break;\n        case DiffOp.Equal:\n          if (diff_text.length <= 2 * this.Patch_Margin &&\n              patchDiffLength && diffs.length != x + 1) {\n            // Small equality inside a patch.\n            patch.diffs[patchDiffLength++] = diffs[x];\n            patch.length1 += diff_text.length;\n            patch.length2 += diff_text.length;\n          } else if (diff_text.length >= 2 * this.Patch_Margin) {\n            // Time for a new patch.\n            if (patchDiffLength) {\n              this.patch_addContext_(patch, prepatch_text);\n              patches.push(patch);\n              patch = new patch_obj();\n              patchDiffLength = 0;\n              // Unlike Unidiff, our patch lists have a rolling context.\n              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n              // Update prepatch text & pos to reflect the application of the\n              // just completed patch.\n              prepatch_text = postpatch_text;\n              char_count1 = char_count2;\n            }\n          }\n          break;\n      }\n\n      // Update the current character count.\n      if (diff_type !== DiffOp.Insert) {\n        char_count1 += diff_text.length;\n      }\n      if (diff_type !== DiffOp.Delete) {\n        char_count2 += diff_text.length;\n      }\n    }\n    // Pick up the leftover patch if not empty.\n    if (patchDiffLength) {\n      this.patch_addContext_(patch, prepatch_text);\n      patches.push(patch);\n    }\n\n    return patches;\n  };\n\n\n  /**\n   * Given an array of patches, return another array that is identical.\n   * @param  patches Array of Patch objects.\n   * @return  Array of Patch objects.\n   */\n    patch_deepCopy (patches: Array<patch_obj>): Array<patch_obj> {\n    // Making deep copies is hard in JavaScript.\n    const patchesCopy = [];\n    for (let x = 0; x < patches.length; x++) {\n      const patch = patches[x];\n      const patchCopy = new patch_obj();\n      patchCopy.diffs = [];\n      for (let y = 0; y < patch.diffs.length; y++) {\n        patchCopy.diffs[y] = [patch.diffs[y][0], patch.diffs[y][1]];\n      }\n      patchCopy.start1 = patch.start1;\n      patchCopy.start2 = patch.start2;\n      patchCopy.length1 = patch.length1;\n      patchCopy.length2 = patch.length2;\n      patchesCopy[x] = patchCopy;\n    }\n    return patchesCopy;\n  };\n\n\n  /**\n   * Merge a set of patches onto the text.  Return a patched text, as well\n   * as a list of true/false values indicating which patches were applied.\n   * @param  patches Array of Patch objects.\n   * @param  text Old text.\n   * @return  Two element Array, containing the\n   *      new text and an array of boolean values.\n   */\n    patch_apply (patches: Array<patch_obj>, text: string) {\n    if (patches.length == 0) {\n      return [text, []];\n    }\n\n    // Deep copy the patches so that no changes are made to originals.\n    patches = this.patch_deepCopy(patches);\n\n    const nullPadding = this.patch_addPadding(patches);\n    text = nullPadding + text + nullPadding;\n\n    this.patch_splitMax(patches);\n    // delta keeps track of the offset between the expected and actual location\n    // of the previous patch.  If there are patches expected at positions 10 and\n    // 20, but the first patch was found at 12, delta is 2 and the second patch\n    // has an effective expected position of 22.\n    let delta = 0;\n    const results = [];\n    for (let x = 0; x < patches.length; x++) {\n      const expected_loc = patches[x].start2 + delta;\n      const text1 = this.diff_text1(patches[x].diffs);\n      let start_loc;\n      let end_loc = -1;\n      if (text1.length > this.Match_MaxBits) {\n        // patch_splitMax will only provide an oversized pattern in the case of\n        // a monster delete.\n        start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                    expected_loc);\n        if (start_loc != -1) {\n          end_loc = this.match_main(text,\n              text1.substring(text1.length - this.Match_MaxBits),\n              expected_loc + text1.length - this.Match_MaxBits);\n          if (end_loc == -1 || start_loc >= end_loc) {\n            // Can't find valid trailing context.  Drop this patch.\n            start_loc = -1;\n          }\n        }\n      } else {\n        start_loc = this.match_main(text, text1, expected_loc);\n      }\n      if (start_loc == -1) {\n        // No match found.  :(\n        results[x] = false;\n        // Subtract the delta for this failed patch from subsequent patches.\n        delta -= patches[x].length2 - patches[x].length1;\n      } else {\n        // Found a match.  :)\n        results[x] = true;\n        delta = start_loc - expected_loc;\n        let text2;\n        if (end_loc == -1) {\n          text2 = text.substring(start_loc, start_loc + text1.length);\n        } else {\n          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n        }\n        if (text1 == text2) {\n          // Perfect match, just shove the replacement text in.\n          text = text.substring(0, start_loc) +\n                this.diff_text2(patches[x].diffs) +\n                text.substring(start_loc + text1.length);\n        } else {\n          // Imperfect match.  Run a diff to get a framework of equivalent\n          // indices.\n          const diffs = this.diff_main(text1, text2, false);\n          if (text1.length > this.Match_MaxBits &&\n              this.diff_levenshtein(diffs) / text1.length >\n              this.Patch_DeleteThreshold) {\n            // The end points match, but the content is unacceptably bad.\n            results[x] = false;\n          } else {\n            this.diff_cleanupSemanticLossless(diffs);\n            let index1 = 0;\n            let index2;\n            for (let y = 0; y < patches[x].diffs.length; y++) {\n              const mod = patches[x].diffs[y];\n              if (mod[0] !== DiffOp.Equal) {\n                index2 = this.diff_xIndex(diffs, index1);\n              }\n              if (mod[0] === DiffOp.Insert) {  // Insertion\n                text = text.substring(0, start_loc + index2) + mod[1] +\n                      text.substring(start_loc + index2);\n              } else if (mod[0] === DiffOp.Delete) {  // Deletion\n                text = text.substring(0, start_loc + index2) +\n                      text.substring(start_loc + this.diff_xIndex(diffs,\n                          index1 + mod[1].length));\n              }\n              if (mod[0] !== DiffOp.Delete) {\n                index1 += mod[1].length;\n              }\n            }\n          }\n        }\n      }\n    }\n    // Strip the padding off.\n    text = text.substring(nullPadding.length, text.length - nullPadding.length);\n    return [text, results];\n  };\n\n\n  /**\n   * Add some padding on text start and end so that edges can match something.\n   * Intended to be called only from within patch_apply.\n   * @param  patches Array of Patch objects.\n   * @return  The padding string added to each side.\n   */\n    patch_addPadding (patches: Array<patch_obj>) {\n    const paddingLength = this.Patch_Margin;\n    let nullPadding = '';\n    for (let x = 1; x <= paddingLength; x++) {\n      nullPadding += String.fromCharCode(x);\n    }\n\n    // Bump all the patches forward.\n    for (let x = 0; x < patches.length; x++) {\n      patches[x].start1 += paddingLength;\n      patches[x].start2 += paddingLength;\n    }\n\n    // Add some padding on start of first diff.\n    let patch = patches[0];\n    let diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[0][0] != DiffOp.Equal) {\n      // Add nullPadding equality.\n      diffs.unshift([DiffOp.Equal, nullPadding]);\n      patch.start1 -= paddingLength;  // Should be 0.\n      patch.start2 -= paddingLength;  // Should be 0.\n      patch.length1 += paddingLength;\n      patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[0][1].length) {\n      // Grow first equality.\n      const extraLength = paddingLength - diffs[0][1].length;\n      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n      patch.start1 -= extraLength;\n      patch.start2 -= extraLength;\n      patch.length1 += extraLength;\n      patch.length2 += extraLength;\n    }\n\n    // Add some padding on end of last diff.\n    patch = patches[patches.length - 1];\n    diffs = patch.diffs;\n    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DiffOp.Equal) {\n      // Add nullPadding equality.\n      diffs.push([DiffOp.Equal, nullPadding]);\n      patch.length1 += paddingLength;\n      patch.length2 += paddingLength;\n    } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n      // Grow last equality.\n      const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n      patch.length1 += extraLength;\n      patch.length2 += extraLength;\n    }\n\n    return nullPadding;\n  };\n\n\n  /**\n   * Look through the patches and break up any which are longer than the maximum\n   * limit of the match algorithm.\n   * Intended to be called only from within patch_apply.\n   * @param  patches Array of Patch objects.\n   */\n    patch_splitMax = function(patches: Array<patch_obj>) {\n    const patch_size = this.Match_MaxBits;\n    for (let x = 0; x < patches.length; x++) {\n      if (patches[x].length1 <= patch_size) {\n        continue;\n      }\n      const bigpatch = patches[x];\n      // Remove the big old patch.\n      patches.splice(x--, 1);\n      let start1 = bigpatch.start1;\n      let start2 = bigpatch.start2;\n      let precontext = '';\n      while (bigpatch.diffs.length !== 0) {\n        // Create one of several smaller patches.\n        const patch = new patch_obj();\n        let empty = true;\n        patch.start1 = start1 - precontext.length;\n        patch.start2 = start2 - precontext.length;\n        if (precontext !== '') {\n          patch.length1 = patch.length2 = precontext.length;\n          patch.diffs.push([DiffOp.Equal, precontext]);\n        }\n        while (bigpatch.diffs.length !== 0 &&\n              patch.length1 < patch_size - this.Patch_Margin) {\n          const diff_type = bigpatch.diffs[0][0];\n          let diff_text = bigpatch.diffs[0][1];\n          if (diff_type === DiffOp.Insert) {\n            // Insertions are harmless.\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n            patch.diffs.push(bigpatch.diffs.shift());\n            empty = false;\n          } else if (diff_type === DiffOp.Delete && patch.diffs.length == 1 &&\n                    patch.diffs[0][0] == DiffOp.Equal &&\n                    diff_text.length > 2 * patch_size) {\n            // This is a large deletion.  Let it pass in one chunk.\n            patch.length1 += diff_text.length;\n            start1 += diff_text.length;\n            empty = false;\n            patch.diffs.push([diff_type, diff_text]);\n            bigpatch.diffs.shift();\n          } else {\n            // Deletion or equality.  Only take as much as we can stomach.\n            diff_text = diff_text.substring(0,\n                patch_size - patch.length1 - this.Patch_Margin);\n            patch.length1 += diff_text.length;\n            start1 += diff_text.length;\n            if (diff_type === DiffOp.Equal) {\n              patch.length2 += diff_text.length;\n              start2 += diff_text.length;\n            } else {\n              empty = false;\n            }\n            patch.diffs.push([diff_type, diff_text]);\n            if (diff_text == bigpatch.diffs[0][1]) {\n              bigpatch.diffs.shift();\n            } else {\n              bigpatch.diffs[0][1] =\n                  bigpatch.diffs[0][1].substring(diff_text.length);\n            }\n          }\n        }\n        // Compute the head context for the next patch.\n        precontext = this.diff_text2(patch.diffs);\n        precontext =\n            precontext.substring(precontext.length - this.Patch_Margin);\n        // Append the end context for this patch.\n        const postcontext = this.diff_text1(bigpatch.diffs)\n                              .substring(0, this.Patch_Margin);\n        if (postcontext !== '') {\n          patch.length1 += postcontext.length;\n          patch.length2 += postcontext.length;\n          if (patch.diffs.length !== 0 &&\n              patch.diffs[patch.diffs.length - 1][0] === DiffOp.Equal) {\n            patch.diffs[patch.diffs.length - 1][1] += postcontext;\n          } else {\n            patch.diffs.push([DiffOp.Equal, postcontext]);\n          }\n        }\n        if (!empty) {\n          patches.splice(++x, 0, patch);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Take a list of patches and return a textual representation.\n   * @param  patches Array of Patch objects.\n   * @return  Text representation of patches.\n   */\n    patch_toText (patches: Array<patch_obj>) {\n    const text = [];\n    for (let x = 0; x < patches.length; x++) {\n      text[x] = patches[x];\n    }\n    return text.join('');\n  };\n\n\n  /**\n   * Parse a textual representation of patches and return a list of Patch objects.\n   * @param  textline Text representation of patches.\n   * @return  Array of Patch objects.\n   * @throws {!Error} If invalid input.\n   */\n    patch_fromText (textline: string): Array<patch_obj> {\n    const patches: Array<patch_obj> = [];\n    if (!textline) {\n      return patches;\n    }\n    const text = textline.split('\\n');\n    let textPointer = 0;\n    const patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n    while (textPointer < text.length) {\n      const m = text[textPointer].match(patchHeader);\n      if (!m) {\n        throw new Error('Invalid patch string: ' + text[textPointer]);\n      }\n      const patch = new patch_obj();\n      patches.push(patch);\n      patch.start1 = parseInt(m[1], 10);\n      if (m[2] === '') {\n        patch.start1--;\n        patch.length1 = 1;\n      } else if (m[2] == '0') {\n        patch.length1 = 0;\n      } else {\n        patch.start1--;\n        patch.length1 = parseInt(m[2], 10);\n      }\n\n      patch.start2 = parseInt(m[3], 10);\n      if (m[4] === '') {\n        patch.start2--;\n        patch.length2 = 1;\n      } else if (m[4] == '0') {\n        patch.length2 = 0;\n      } else {\n        patch.start2--;\n        patch.length2 = parseInt(m[4], 10);\n      }\n      textPointer++;\n\n      while (textPointer < text.length) {\n        const sign = text[textPointer].charAt(0);\n        let line: string;\n        try {\n          line = decodeURI(text[textPointer].substring(1));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in patch_fromText: ' + line);\n        }\n        if (sign == '-') {\n          // Deletion.\n          patch.diffs.push([DiffOp.Delete, line]);\n        } else if (sign == '+') {\n          // Insertion.\n          patch.diffs.push([DiffOp.Insert, line]);\n        } else if (sign == ' ') {\n          // Minor equality.\n          patch.diffs.push([DiffOp.Equal, line]);\n        } else if (sign == '@') {\n          // Start of next patch.\n          break;\n        } else if (sign === '') {\n          // Blank line?  Whatever.\n        } else {\n          // WTF?\n          throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n        }\n        textPointer++;\n      }\n    }\n    return patches;\n  };\n\n}\n\n\n/**\n * Class representing one patch operation.\n\n */\nexport class patch_obj {\n\n  constructor() {  }\n\n  diffs: Array<Diff> = [];\n  start1: number = null;\n  start2: number = null;\n  length1: number = 0;\n  length2: number = 0;\n\n  /**\n   * Emmulate GNU diff's format.\n   * Header: @@ -382,8 +481,9 @@\n   * Indicies are printed as 1-based, not 0-based.\n   */\n  toString = function() {\n    let coords1, coords2;\n    if (this.length1 === 0) {\n      coords1 = this.start1 + ',0';\n    } else if (this.length1 == 1) {\n      coords1 = this.start1 + 1;\n    } else {\n      coords1 = (this.start1 + 1) + ',' + this.length1;\n    }\n    if (this.length2 === 0) {\n      coords2 = this.start2 + ',0';\n    } else if (this.length2 == 1) {\n      coords2 = this.start2 + 1;\n    } else {\n      coords2 = (this.start2 + 1) + ',' + this.length2;\n    }\n    const text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n    let op;\n    // Escape the body of the patch with %xx notation.\n    for (let x = 0; x < this.diffs.length; x++) {\n      switch (this.diffs[x][0]) {\n        case DiffOp.Insert:\n          op = '+';\n          break;\n        case DiffOp.Delete:\n          op = '-';\n          break;\n        case DiffOp.Equal:\n          op = ' ';\n          break;\n      }\n      text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n    }\n    return text.join('').replace(/%20/g, ' ');\n  }\n}\n\nexport { DiffMatchPatch };\n","import { Injectable, OnInit } from '@angular/core';\nimport { DiffMatchPatch, DiffOp } from './diffMatchPatch';\n\n@Injectable()\nexport class DiffMatchPatchService implements OnInit {\n\n  constructor(private dmp: DiffMatchPatch) {   }\n\n  ngOnInit () {\n\n  }\n\n  getDiff(left: string, right: string) {\n     return this.dmp.diff_main(left, right);\n  }\n\n  getSemanticDiff(left: string, right: string) {\n    const diffs = this.dmp.diff_main(left, right);\n    this.dmp.diff_cleanupSemantic(diffs);\n    return diffs;\n  }\n\n  getProcessingDiff(left: string, right: string) {\n    const diffs = this.dmp.diff_main(left, right);\n    this.dmp.diff_cleanupEfficiency(diffs);\n    return diffs;\n  }\n\n  getLineDiff(left: string, right: string) {\n    const chars = this.dmp.diff_linesToChars_(left, right);\n    const diffs = this.dmp.diff_main(chars.chars1, chars.chars2, false);\n    this.dmp.diff_charsToLines_(diffs, chars.lineArray);\n    return diffs;\n  }\n\n  getDmp() {\n    return this.dmp;\n  }\n\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Component, Input, OnInit, OnChanges } from '@angular/core';\nimport { Diff, DiffOp } from './diffMatchPatch';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\n\n/* Holds the state of the calculation of the diff result we intend to display.\n *  > lines contains the data that will be displayed on screen.\n *  > lineLeft keeps track of the document line number in the [left] input.\n *  > lineRight keeps track of the document line number in the [right] input.\n */\ntype DiffCalculation = {\n  lines: Array<[string, string, string, string]>,\n  lineLeft: number,\n  lineRight: number\n};\n\n@Component({\n  selector: 'dmp-line-compare',\n  styles: [`\n    div.dmp-line-compare {\n      display: flex;\n      flex-direction: row;\n      border: 1px solid #808080;\n      font-family: Consolas, Courier, monospace;\n      width: 911px;\n    }\n    div.dmp-line-compare-margin {\n      width: 101px;\n    }\n    div.dmp-line-compare-content {\n      position: relative;\n      top: 0px;\n      left: 0px;\n      flex-grow: 1;\n      overflow-x: scroll;\n    }\n    div.dmp-line-compare-content-wrapper {\n      position: absolute;\n      top: 0px;\n      left: 0px;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n    div.dmp-line-compare-left {\n      width: 50px;\n      text-align: center;\n      color: #484848;\n    }\n    div.dmp-line-compare-equal>div.dmp-line-compare-left,\n      div.dmp-line-compare-equal>div.dmp-line-compare-right {\n      background-color: #dedede;\n    }\n    div.dmp-line-compare-insert>div.dmp-line-compare-left,\n      div.dmp-line-compare-insert>div.dmp-line-compare-right {\n      background-color: #8bfb6f;\n    }\n    div.dmp-line-compare-delete>div.dmp-line-compare-left,\n      div.dmp-line-compare-delete>div.dmp-line-compare-right {\n      background-color: #f56868;\n    }\n    div.dmp-line-compare-right {\n      width: 50px;\n      text-align: center;\n      color: #484848;\n      border-right: 1px solid #888888;\n    }\n    div.dmp-line-compare-text {\n      white-space: pre;\n      padding-left: 10px;\n      min-width: 800px;\n    }\n    .dmp-line-compare-delete {\n      background-color: #ff8c8c;\n    }\n    .dmp-line-compare-insert {\n      background-color: #9dff97;\n    }\n    .dmp-line-compare-delete>div {\n      display: inline-block;\n    }  \n    .dmp-line-compare-insert>div {\n      display: inline-block;\n    }\n    .dmp-line-compare-equal>div {\n      display: inline-block;\n    }\n    .dmp-margin-bottom-spacer {\n      height: 20px;\n      background-color: #dedede;\n      border-right: 1px solid #888888;\n    }\n  `],\n  template: `\n    <div class=\"dmp-line-compare-no-changes-text\" *ngIf=\"isContentEqual\">\n      There are no changes to display.\n    </div>    \n    <div class=\"dmp-line-compare\" *ngIf=\"!isContentEqual\">\n      <div class=\"dmp-line-compare-margin\">\n        <div [ngClass]=\"lineDiff[0]\" *ngFor=\"let lineDiff of calculatedDiff\">\n          <div class=\"dmp-line-compare-left\">{{lineDiff[1]}}</div><!-- No space\n        --><div class=\"dmp-line-compare-right\">{{lineDiff[2]}}</div>\n        </div>\n        <div class=\"dmp-margin-bottom-spacer\"></div>\n      </div><!-- No space\n   --><div class=\"dmp-line-compare-content\">\n        <div class=\"dmp-line-compare-content-wrapper\">\n          <div [ngClass]=\"lineDiff[0]\" *ngFor=\"let lineDiff of calculatedDiff\">\n            <div class=\"dmp-line-compare-text\">{{lineDiff[3]}}</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  `\n})\nexport class LineCompareComponent implements OnInit, OnChanges {\n  @Input()\n  public left: string | number | boolean;\n  @Input()\n  public right: string | number | boolean;\n  // The number of lines of context to provide either side of a DiffOp.Insert or DiffOp.Delete diff.\n  // Context is taken from a DiffOp.Equal section.\n  @Input()\n  public lineContextSize: number;\n\n  public calculatedDiff: Array<[string, string, string, string]>;\n  public isContentEqual: boolean;\n\n  public constructor(\n      private dmp: DiffMatchPatchService) {}\n\n  public ngOnInit(): void {\n    this.updateHtml();\n  }\n\n  public ngOnChanges(): void {\n    this.updateHtml();\n  }\n\n  private updateHtml(): void {\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n      this.left = this.left.toString();\n    }\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n      this.right = this.right.toString();\n    }\n    this.calculateLineDiff(this.dmp.getLineDiff(this.left, this.right));\n  }\n\n  private calculateLineDiff(diffs: Array<Diff>): void {\n    const diffCalculation: DiffCalculation = {\n      lines: [],\n      lineLeft: 1,\n      lineRight: 1\n    };\n\n    this.isContentEqual = diffs.length === 1 && diffs[0][0] === DiffOp.Equal;\n    if (this.isContentEqual) {\n      this.calculatedDiff = [];\n      return;\n    }\n\n    for (let i = 0; i < diffs.length; i++) {\n      const diff = diffs[i];\n      let diffLines: string[] = diff[1].split(/\\r?\\n/);\n\n      // If the original line had a \\r\\n at the end then remove the\n      // empty string after it.\n      if (diffLines[diffLines.length - 1].length == 0) {\n        diffLines.pop();\n      }\n\n      switch (diff[0]) {\n        case DiffOp.Equal: {\n          const isFirstDiff = i === 0;\n          const isLastDiff = i === diffs.length - 1;\n          this.outputEqualDiff(diffLines, diffCalculation, isFirstDiff, isLastDiff);\n          break;\n        }\n        case DiffOp.Delete: {\n          this.outputDeleteDiff(diffLines, diffCalculation);\n          break;\n        }\n        case DiffOp.Insert: {\n          this.outputInsertDiff(diffLines, diffCalculation);\n          break;\n        }\n      }\n    }\n\n    this.calculatedDiff = diffCalculation.lines;\n  }\n\n  /* If the number of diffLines is greater than lineContextSize then we may need to adjust the diff\n   * that is output.\n   *   > If the first diff of a document is DiffOp.Equal then the leading lines can be dropped\n   *     leaving the last 'lineContextSize' lines for context.\n   *   > If the last diff of a document is DiffOp.Equal then the trailing lines can be dropped\n   *     leaving the first 'lineContextSize' lines for context.\n   *   > If the diff is a DiffOp.Equal occurs in the middle then the diffs either side of it must be\n   *     DiffOp.Insert or DiffOp.Delete. If it has more than 2 * 'lineContextSize' lines of content\n   *     then the middle lines are dropped leaving the first 'lineContextSize' and last 'lineContextSize'\n   *     lines for context. A special line is inserted with '...' indicating that content is skipped.\n   *\n   * A document cannot consist of a single Diff with DiffOp.Equal and reach this function because\n   * in this case the calculateLineDiff method returns early.\n   */\n  private outputEqualDiff(\n      diffLines: string[],\n      diffCalculation: DiffCalculation,\n      isFirstDiff: boolean,\n      isLastDiff: boolean): void {\n    if (this.lineContextSize && diffLines.length > this.lineContextSize) {\n      if (isFirstDiff) {\n        // Take the last 'lineContextSize' lines from the first diff\n        const lineIncrement = diffLines.length - this.lineContextSize;\n        diffCalculation.lineLeft += lineIncrement;\n        diffCalculation.lineRight += lineIncrement;\n        diffLines = diffLines.slice(diffLines.length - this.lineContextSize, diffLines.length);\n      }\n      else if (isLastDiff) {\n        // Take only the first 'lineContextSize' lines from the final diff\n        diffLines = diffLines.slice(0, this.lineContextSize);\n      }\n      else if (diffLines.length > 2 * this.lineContextSize) {\n        // Take the first 'lineContextSize' lines from this diff to provide context for the last diff\n        this.outputEqualDiffLines(diffLines.slice(0, this.lineContextSize), diffCalculation);\n\n        // Output a special line indicating that some content is equal and has been skipped\n        diffCalculation.lines.push(['dmp-line-compare-equal', '...', '...', '...']);\n        const numberOfSkippedLines = diffLines.length - (2 * this.lineContextSize);\n        diffCalculation.lineLeft += numberOfSkippedLines;\n        diffCalculation.lineRight += numberOfSkippedLines;\n\n        // Take the last 'lineContextSize' lines from this diff to provide context for the next diff\n        this.outputEqualDiffLines(diffLines.slice(diffLines.length - this.lineContextSize), diffCalculation);\n        // This if branch has already output the diff lines so we return early to avoid outputting the lines\n        // at the end of the method.\n        return;\n      }\n    }\n    this.outputEqualDiffLines(diffLines, diffCalculation);\n  }\n\n  private outputEqualDiffLines(\n      diffLines: string[],\n      diffCalculation: DiffCalculation): void {\n    for (const line of diffLines) {\n      diffCalculation.lines.push(['dmp-line-compare-equal', `${diffCalculation.lineLeft}`, `${diffCalculation.lineRight}`, line]);\n      diffCalculation.lineLeft++;\n      diffCalculation.lineRight++;\n    }\n  }\n\n  private outputDeleteDiff(\n      diffLines: string[],\n      diffCalculation: DiffCalculation): void {\n    for (const line of diffLines) {\n      diffCalculation.lines.push(['dmp-line-compare-delete', `${diffCalculation.lineLeft}`, '-', line]);\n      diffCalculation.lineLeft++;\n    }\n  }\n\n  private outputInsertDiff(\n      diffLines: string[],\n      diffCalculation: DiffCalculation): void {\n    for (const line of diffLines) {\n      diffCalculation.lines.push(['dmp-line-compare-insert', '-', `${diffCalculation.lineRight}`, line]);\n      diffCalculation.lineRight++;\n    }\n  }\n}\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\nimport { Diff, DiffOp } from './diffMatchPatch';\n\n@Directive({\n  selector: '[diff]'\n})\nexport class DiffDirective implements OnInit, OnChanges {\n\n  @Input() left: string;\n  @Input() right: string;\n\n  public constructor(\n    private el: ElementRef,\n    private dmp: DiffMatchPatchService) {  }\n\n  public ngOnInit(): void {\n    this.updateHtml();\n  }\n\n  public ngOnChanges(): void {\n    this.updateHtml();\n  }\n\n  private updateHtml(): void {\n    this.el.nativeElement.innerHTML = this.createHtml(\n      this.dmp.getDiff(this.left, this.right));\n  }\n  \n  private createHtml(diffs: Array<Diff>): string {\n    let html: string;\n    html = '<div>';\n    for(let diff of diffs) {\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\n\n      if(diff[0] === DiffOp.Equal) {\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\n      }\n      if(diff[0] === DiffOp.Delete) {\n        html += '<del>' + diff[1] + '</del>';\n      }\n      if(diff[0] === DiffOp.Insert) {\n        html += '<ins>' + diff[1] + '</ins>';\n      }\n    }\n    html += '</div>';\n    return html;\n  }\n}\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\nimport { Diff, DiffOp } from './diffMatchPatch';\n\n@Directive({\n  selector: '[lineDiff]',\n})\nexport class LineDiffDirective implements OnInit, OnChanges {\n  @Input() left: string | number | boolean;\n  @Input() right: string | number | boolean;\n\n  public constructor(\n    private el: ElementRef,\n    private dmp: DiffMatchPatchService) {  }\n\n  public ngOnInit(): void {\n    this.updateHtml();\n  }\n\n  public ngOnChanges(): void {\n    this.updateHtml();\n  }\n\n  private updateHtml(): void {\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n      this.left = this.left.toString();\n    }\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n      this.right = this.right.toString();\n    }\n    this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getLineDiff(this.left, this.right));\n  }\n\n  // TODO: Need to fix this for line diffs\n  private createHtml(diffs: Array<Diff>): string {\n    let html: string;\n    html = '<div>';\n    for (let diff of diffs) {\n      if (diff[0] === DiffOp.Equal) {\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\n      }\n      if (diff[0] === DiffOp.Delete) {\n        html += '<div class=\\\"del\\\"> - <del>' + diff[1] + '</del></div>\\n';\n      }\n      if (diff[0] === DiffOp.Insert) {\n        html += '<div class=\\\"ins\\\"> + <ins>' + diff[1] + '</ins></div>\\n';\n      }\n    }\n    html += '</div>';\n    return html;\n  }\n}\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\nimport { Diff, DiffOp } from './diffMatchPatch';\n\n@Directive({\n  selector: '[processingDiff]'\n})\nexport class ProcessingDiffDirective implements OnInit, OnChanges {\n  @Input() left: string;\n  @Input() right: string;\n\n  public constructor(\n    private el: ElementRef,\n    private dmp: DiffMatchPatchService) {  }\n\n  public ngOnInit(): void {\n    this.updateHtml();\n  }\n\n  public ngOnChanges(): void {\n    this.updateHtml();\n  }\n\n  private updateHtml(): void {\n    this.el.nativeElement.innerHTML = this.createHtml(\n      this.dmp.getProcessingDiff(this.left, this.right));\n  }\n\n  // TODO: Need to fix this for line diffs\n  private createHtml(diffs: Array<Diff>): string {\n    let html: string;\n    html = '<div>';\n    for (let diff of diffs) {\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\n\n      if (diff[0] === DiffOp.Equal) {\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\n      }\n      if (diff[0] === DiffOp.Delete) {\n        html += '<del>' + diff[1] + '</del>';\n      }\n      if (diff[0] === DiffOp.Insert) {\n        html += '<ins>' + diff[1] + '</ins>';\n      }\n    }\n    html += '</div>';\n    return html;\n  }\n}\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\nimport { Diff, DiffOp } from './diffMatchPatch';\n\n@Directive({\n  selector: '[semanticDiff]'\n})\nexport class SemanticDiffDirective implements OnInit, OnChanges {\n  @Input() left: string | number | boolean;\n  @Input() right: string | number | boolean;\n\n  public constructor(\n    private el: ElementRef,\n    private dmp: DiffMatchPatchService) {  }\n\n  public ngOnInit(): void {\n    this.updateHtml();\n  }\n\n  public ngOnChanges(): void {\n    this.updateHtml();\n  }\n\n  private updateHtml(): void {\n    if (!this.left) {\n      this.left = \"\";\n    }\n    if (!this.right) {\n      this.right = \"\";\n    }\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\n      this.left = this.left.toString();\n    }\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\n      this.right = this.right.toString();\n    }\n    this.el.nativeElement.innerHTML = this.createHtml(\n      this.dmp.getSemanticDiff(this.left, this.right));\n  }\n\n  // TODO: Need to fix this for line diffs\n  private createHtml(diffs: Array<Diff>): string {\n    let html: string;\n    html = '<div>';\n    for (let diff of diffs) {\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\n\n      if (diff[0] === DiffOp.Equal) {\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\n      }\n      if (diff[0] === DiffOp.Delete) {\n        html += '<del>' + diff[1] + '</del>';\n      }\n      if (diff[0] === DiffOp.Insert) {\n        html += '<ins>' + diff[1] + '</ins>';\n      }\n    }\n    html += '</div>';\n    return html;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { DiffDirective } from './diff.directive';\nimport { LineDiffDirective } from './lineDiff.directive';\nimport { ProcessingDiffDirective } from './processingDiff.directive';\nimport { SemanticDiffDirective } from './semanticDiff.directive';\nimport { LineCompareComponent } from './lineCompare.component';\n\nimport { DiffMatchPatch } from './diffMatchPatch';\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\n\n@NgModule({\n  declarations: [\n    DiffDirective,\n    LineDiffDirective,\n    ProcessingDiffDirective,\n    SemanticDiffDirective,\n    LineCompareComponent\n  ],\n  imports: [\n    CommonModule\n  ],\n  exports: [\n    DiffDirective,\n    LineDiffDirective,\n    ProcessingDiffDirective,\n    SemanticDiffDirective,\n    LineCompareComponent\n  ],\n  providers: [\n    DiffMatchPatch,\n    DiffMatchPatchService\n  ]\n})\nexport class DiffMatchPatchModule { }\n"],"names":["Injectable","tslib_1.__values","Component","Input","Directive","ElementRef","NgModule","CommonModule"],"mappings":"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"}
